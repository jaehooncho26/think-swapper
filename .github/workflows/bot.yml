name: gala-hackathon-bot

on:
  schedule:
    - cron: "*/10 * * * *"
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Run in DRY_RUN mode (no live trades)"
        type: choice
        required: true
        default: "true"
        options: ["true","false"]

permissions:
  contents: read

env:
  API_BASE: https://dex-backend-test1.defi.gala.com

  # ===== Base DCA strategy =====
  DCA_USD_PER_ASSET: "5"
  BASE_TP_PCT: "0.4"

  # ===== Arbitrage strategy =====
  MIN_PROFIT_PCT: "0.8"
  STRONG_SIGNAL_PCT: "1.6"
  ARB_MIN_USD: "5"
  ARB_MAX_USD: "30"

  # ===== Safety / execution =====
  DEFAULT_FEE_TIER: "3000"
  SLIPPAGE_PCT: "0.6"
  MAX_POSITION_USD_PER_TOKEN: "150"
  MAX_NET_EXPOSURE_USD: "300"
  CIRCUIT_BREAKER_MAX_FAILS: "4"

  # ===== Token composite keys (GalaChain) =====
  T_GUSDC: "GUSDC$Unit$none$none"
  T_GALA:  "GALA$Unit$none$none"
  T_GWETH: "GWETH$Unit$none$none"

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Restore state cache
        uses: actions/cache@v4
        with:
          path: .bot-state
          key: bot-state-v3
          restore-keys: |
            bot-state-

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install deps
        run: |
          npm init -y >/dev/null 2>&1
          npm i @gala-chain/api

      - name: Prepare folders & placeholders
        run: |
          mkdir -p .bot-state .bot-logs
          [ -f .bot-state/state.json ] || echo '{"positions":{"GALA":{"qty":0,"avg":0},"GWETH":{"qty":0,"avg":0}},"pnl":{"realized_usdc":0,"cycles":0,"wins":0,"losses":0}}' > .bot-state/state.json
          echo "timestamp,type,token,side,usd,token_qty,price_usd,txid_or_key,notes" > .bot-logs/placeholder.csv
          echo '{"status":"init"}' > .bot-logs/placeholder.json

      - name: Run bot
        env:
          WALLET_ADDRESS: ${{ secrets.WALLET_ADDRESS }}   # any valid GalaChain wallet string
          PRIVATE_KEY:    ${{ secrets.PRIVATE_KEY }}      # hex, starts with 0x
          DRY_RUN:        ${{ inputs.dry_run || 'true' }}
        run: |
          node - <<'NODE'
          import fs from "node:fs";
          import path from "node:path";
          import crypto from "node:crypto";
          import { signatures } from "@gala-chain/api";

          // ===== Config & helpers =====
          const API_BASE = process.env.API_BASE;
          const DRY_RUN  = (process.env.DRY_RUN || "true").toLowerCase()==="true";
          const WALLET   = process.env.WALLET_ADDRESS;     // GalaChain wallet (no eth| prefix required)
          const PRIVKEY  = process.env.PRIVATE_KEY;        // must be 0x... hex for signing

          const DCA_USD       = num(process.env.DCA_USD_PER_ASSET || "5");
          const BASE_TP       = num(process.env.BASE_TP_PCT || "0.4")/100;
          const MIN_PROFIT    = num(process.env.MIN_PROFIT_PCT || "0.8")/100;
          const STRONG_SIG    = num(process.env.STRONG_SIGNAL_PCT || "1.6")/100;
          const ARB_MIN_USD   = num(process.env.ARB_MIN_USD || "5");
          const ARB_MAX_USD   = num(process.env.ARB_MAX_USD || "30");
          const FEE_TIER      = parseInt(process.env.DEFAULT_FEE_TIER || "3000",10);
          const SLIP          = num(process.env.SLIPPAGE_PCT || "0.6")/100;
          const MAX_POS_EACH  = num(process.env.MAX_POSITION_USD_PER_TOKEN || "150");
          const MAX_POS_NET   = num(process.env.MAX_NET_EXPOSURE_USD || "300");
          const MAX_FAILS     = parseInt(process.env.CIRCUIT_BREAKER_MAX_FAILS || "4",10);

          const T = {
            GUSDC: process.env.T_GUSDC,
            GALA:  process.env.T_GALA,
            GWETH: process.env.T_GWETH
          };

          function num(x){ return Number(x); }
          const stateDir = ".bot-state";
          const statePath = path.join(stateDir, "state.json");
          const logDir = ".bot-logs";
          const runId = Date.now();
          const csvPath = path.join(logDir, `trades_${runId}.csv`);
          const jsonPath = path.join(logDir, `run_${runId}.json`);

          // basic validation
          if (!WALLET || typeof WALLET !== "string") throw new Error("WALLET_ADDRESS missing/invalid");
          if (!PRIVKEY?.startsWith("0x")) throw new Error("PRIVATE_KEY must start with 0x...");

          fs.writeFileSync(csvPath, "timestamp,type,token,side,usd,token_qty,price_usd,txid_or_key,notes\n", {flag:"a"});

          function loadState(){
            try { return JSON.parse(fs.readFileSync(statePath, "utf8")); }
            catch {
              return { positions: { GALA: { qty:0, avg:0 }, GWETH: { qty:0, avg:0 } },
                       pnl: { realized_usdc:0, cycles:0, wins:0, losses:0 } };
            }
          }
          function saveState(s){ fs.writeFileSync(statePath, JSON.stringify(s, null, 2)); }
          function logCSV(...cols){ fs.writeFileSync(csvPath, cols.join(",")+"\n", {flag:"a"}); }
          async function delay(ms){ return new Promise(r=>setTimeout(r, ms)); }
          async function jitter(){ const j = Math.floor(Math.random()*60000); await delay(j); }

          // ===== HTTP helpers =====
          async function apiGet(path, params){
            const u = new URL(path, API_BASE);
            Object.entries(params||{}).forEach(([k,v])=>u.searchParams.set(k,String(v)));
            const r = await fetch(u);
            if(!r.ok) throw new Error(`${path} ${r.status} ${await r.text()}`);
            return r.json();
          }
          async function apiPost(path, body){
            const r = await fetch(`${API_BASE}${path}`, { method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify(body) });
            if(!r.ok) throw new Error(`${path} ${r.status} ${await r.text()}`);
            return r.json();
          }

          async function price(tokenKey){
            const j = await apiGet("/v1/trade/price", { token: tokenKey });
            const p = j?.data?.price ?? j?.price;
            return num(p);
          }
          async function quote(tokenIn, tokenOut, amountIn, fee=FEE_TIER){
            const j = await apiGet("/v1/trade/quote", { tokenIn, tokenOut, amountIn, fee });
            const d = j.data || j;
            return num(d.amountOut || 0);
          }
          async function getBalance(user, tokenKey){
            // In DRY_RUN, bypass actual balance so you can test with 0 funds
            if (DRY_RUN) return Number.MAX_SAFE_INTEGER;
            const j = await apiGet("/v1/trade/balance", { user, token: tokenKey });
            const d = j.data || j;
            return num(d.balance || 0);
          }
          function toObj(k){ const [collection,category,type,additionalKey] = k.split("$"); return { collection, category, type, additionalKey }; }
          async function swapPayload(tokenIn, tokenOut, amountIn, amountOutMin, fee=FEE_TIER){
            const body = {
              tokenIn: toObj(tokenIn),
              tokenOut: toObj(tokenOut),
              amountIn: String(amountIn),
              fee,
              sqrtPriceLimit: "0",
              amountInMaximum: String(amountIn),
              amountOutMinimum: String(Math.max(0, amountOutMin || 0))  // keep non-negative for compatibility
            };
            const j = await apiPost("/v1/trade/swap", body);
            return j.data;
          }
          async function bundle(payload, type="swap"){
            const key = signatures.normalizePrivateKey(PRIVKEY);
            const withKey = { ...payload, uniqueKey: payload.uniqueKey || `galaswap-operation-${crypto.randomUUID()}` };
            const signature = signatures.getSignature(withKey, key);
            const j = await apiPost("/v1/trade/bundle", { payload: withKey, type, signature, user: WALLET });
            return j.data?.data || j.data; // tx id
          }
          async function execSwap(tokenIn, tokenOut, amountIn, expectedOut){
            const minOut = expectedOut * (1 - SLIP);
            const payload = await swapPayload(tokenIn, tokenOut, amountIn, minOut, FEE_TIER);
            if (DRY_RUN) return { dry:true, id: payload.uniqueKey };
            const id = await bundle(payload, "swap");
            return { dry:false, id };
          }
          function sizeForProfit(p){ return p >= STRONG_SIG ? ARB_MAX_USD : Math.round((ARB_MIN_USD + Math.random()*5)*100)/100; }
          function exposureUSD(state, galaPx, wethPx){
            const galaUSD = state.positions.GALA.qty * galaPx;
            const wethUSD = state.positions.GWETH.qty * wethPx;
            return { galaUSD, wethUSD, net: galaUSD + wethUSD };
          }
          async function evalLoop(spend, seq){
            let amt = spend; const legs = [];
            for (let i=0;i<seq.length-1;i++){
              const tin = T[seq[i]], tout = T[seq[i+1]];
              const out = await quote(tin, tout, amt, FEE_TIER);
              if (!out || out<=0) return { ok:false };
              legs.push({ tokenIn: tin, tokenOut: tout, amountIn: amt, expectedOut: out });
              amt = out;
            }
            const profitPct = (amt - spend)/spend;
            return { ok:true, legs, profitPct, start: spend, final: amt, path: seq };
          }

          (async ()=>{
            console.log("⏱️  Start cycle | DRY_RUN:", DRY_RUN, "|", new Date().toISOString());
            await jitter();

            const state = loadState();
            const [galaPx, gwethPx] = await Promise.all([ price(T.GALA), price(T.GWETH) ]);
            console.log(`💹 Prices → GALA=$${galaPx.toFixed(6)} | GWETH=$${gwethPx.toFixed(2)}`);

            // GUSDC balance (bypassed in DRY_RUN)
            let gusdcBal = await getBalance(WALLET, T.GUSDC);
            console.log(`💰 Balance GUSDC=${gusdcBal === Number.MAX_SAFE_INTEGER ? "∞ (dry-run)" : gusdcBal.toFixed(4)}`);

            const exp = exposureUSD(state, galaPx, gwethPx);
            const tooMuchNet = exp.net >= MAX_POS_NET;
            const tooMuchGala = exp.galaUSD >= MAX_POS_EACH;
            const tooMuchWeth = exp.wethUSD >= MAX_POS_EACH;
            let fails = 0;

            // ---- Take-profit first ----
            for (const sym of ["GALA","GWETH"]){
              const pos = state.positions[sym]; if (!pos || pos.qty<=0) continue;
              const px = sym==="GALA" ? galaPx : gwethPx;
              const target = pos.avg * (1 + BASE_TP);
              if (px >= target){
                const maxSellUsd = Math.min(ARB_MAX_USD, pos.qty * px);
                const sellQty = Math.min(pos.qty, maxSellUsd / px);
                if (sellQty > 0){
                  try{
                    const outUSDC = await quote(T[sym], T.GUSDC, sellQty, FEE_TIER);
                    const r = await execSwap(T[sym], T.GUSDC, sellQty, outUSDC);
                    state.positions[sym].qty -= sellQty;
                    if (state.positions[sym].qty <= 1e-12) { state.positions[sym] = { qty:0, avg:0 }; }
                    state.pnl.realized_usdc += outUSDC - (sellQty * pos.avg);
                    logCSV(Date.now(),"tp",sym,"SELL",(sellQty*px).toFixed(2),sellQty.toFixed(8),px.toFixed(8),r.id,`tp>=${(BASE_TP*100).toFixed(2)}%`);
                    console.log(`🔵 TP SELL ${sym}: ~${(sellQty*px).toFixed(2)} → tx=${r.id}`);
                  } catch(e){ console.log("sell error:", e.message); if(++fails>=MAX_FAILS) console.log("🛑 circuit breaker"); }
                }
              }
            }

            // ---- DCA ($5 each), respect exposure + balance ----
            const dcaEach = DCA_USD;
            const net = exp.net;
            const capOK = (net + 2*dcaEach) <= MAX_POS_NET;

            const tryDca = async (sym, px)=>{
              if (!capOK) { console.log(`⛔ DCA ${sym} skipped: net cap`); return; }
              if ((sym==="GALA" && tooMuchGala) || (sym==="GWETH" && tooMuchWeth)) { console.log(`⛔ DCA ${sym} skipped: token cap`); return; }
              if (gusdcBal < dcaEach) { console.log(`⛔ DCA ${sym} skipped: insufficient GUSDC`); return; }
              try{
                const out = await quote(T.GUSDC, T[sym], dcaEach, FEE_TIER);
                const r = await execSwap(T.GUSDC, T[sym], dcaEach, out);
                const pos = state.positions[sym];
                const newQty = pos.qty + out;
                const newCost = (pos.qty*pos.avg + dcaEach) / newQty;
                state.positions[sym] = { qty:newQty, avg:newCost };
                gusdcBal -= dcaEach;
                logCSV(Date.now(),"dca",sym,"BUY",dcaEach.toFixed(2),out.toFixed(8),(dcaEach/out).toFixed(8),r.id,"dca");
                console.log(`🟢 DCA BUY ${sym} $${dcaEach} → tx=${r.id}`);
              } catch(e){ console.log(`dca ${sym} error:`, e.message); if(++fails>=MAX_FAILS) console.log("🛑 circuit breaker"); }
            };

            await tryDca("GALA", galaPx);
            await tryDca("GWETH", gwethPx);

            // ---- Triangular arbitrage scan ----
            if (fails < MAX_FAILS){
              const loops = [
                ["GUSDC","GALA","GWETH","GUSDC"],
                ["GUSDC","GWETH","GALA","GUSDC"]
              ];
              let best = null;
              for (const seq of loops){
                const est = await evalLoop(Math.min(ARB_MIN_USD, gusdcBal), seq);
                if (!est.ok) continue;
                if (!best || est.profitPct > best.profitPct) best = est;
              }
              if (best && best.profitPct >= MIN_PROFIT){
                const desired = best.profitPct >= STRONG_SIG ? ARB_MAX_USD : Math.max(ARB_MIN_USD, 5);
                const size = Math.min(desired, gusdcBal);
                if (size >= 0.5){
                  const check = await evalLoop(size, best.path);
                  if (check.ok && check.profitPct >= MIN_PROFIT){
                    console.log(`🎯 ARB ${check.path.join("→")} | $${size} | exp=${(check.profitPct*100).toFixed(3)}%`);
                    for (const leg of check.legs){
                      try{
                        const r = await execSwap(leg.tokenIn, leg.tokenOut, leg.amountIn, leg.expectedOut);
                        logCSV(Date.now(),"arb","NA","SWAP",leg.amountIn.toFixed(6),"NA","NA",r.id,`${leg.tokenIn}->${leg.tokenOut}`);
                      } catch(e){ console.log("arb leg error:", e.message); if(++fails>=MAX_FAILS){ console.log("🛑 circuit breaker"); break; } }
                    }
                    gusdcBal -= size;
                  } else {
                    console.log("⚖️  Arb signal faded at size");
                  }
                } else {
                  console.log("⛔ Not enough GUSDC for arb size");
                }
              } else {
                console.log("😴 No arb ≥ MIN_PROFIT or insufficient balance");
              }
            }

            const summary = {
              time: new Date().toISOString(),
              prices: { GALA: galaPx, GWETH: gwethPx },
              gusdcBalanceAfter: gusdcBal,
              dryRun: DRY_RUN
            };

            const state = loadState();
            state.pnl.cycles += 1;
            saveState(state);
            fs.writeFileSync(jsonPath, JSON.stringify(summary, null, 2));

            console.log("✅ cycle done");
          })().catch(err=>{
            const out = { time: new Date().toISOString(), error: String(err?.message||err), stack: err?.stack||null };
            fs.writeFileSync(path.join(".bot-logs", `run_error_${Date.now()}.json`), JSON.stringify(out,null,2));
            console.error("❌ bot error:", err);
            process.exit(1);
          });
          NODE

      - name: Upload logs (artifact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gala-bot-logs
          path: |
            .bot-logs/*.csv
            .bot-logs/*.json
          if-no-files-found: warn

      - name: Save state cache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: .bot-state
          key: bot-state-v3-${{ github.run_id }}
