name: gala-hackathon-bot (debug)

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: "DRY_RUN (use true while debugging)"
        type: choice
        required: true
        default: "true"
        options: ["true","false"]

permissions:
  contents: read

env:
  API_BASE: https://dex-backend-test1.defi.gala.com

  # --- Strategy (kept minimal while debugging) ---
  DCA_USD_PER_ASSET: "1"
  BASE_TP_PCT: "0.4"
  MIN_PROFIT_PCT: "0.8"
  STRONG_SIGNAL_PCT: "1.6"
  ARB_MIN_USD: "1"
  ARB_MAX_USD: "1"

  DEFAULT_FEE_TIER: "3000"
  SLIPPAGE_PCT: "0.6"
  MAX_POSITION_USD_PER_TOKEN: "25"
  MAX_NET_EXPOSURE_USD: "50"
  CIRCUIT_BREAKER_MAX_FAILS: "2"

  T_GUSDC: "GUSDC$Unit$none$none"
  T_GALA:  "GALA$Unit$none$none"
  T_GWETH: "GWETH$Unit$none$none"

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install deps
        run: |
          npm init -y >/dev/null 2>&1
          npm i @gala-chain/api

      - name: Prepare dirs & placeholders
        run: |
          mkdir -p .bot-state .bot-logs
          [ -f .bot-state/state.json ] || echo '{"positions":{"GALA":{"qty":0,"avg":0},"GWETH":{"qty":0,"avg":0}},"pnl":{"realized_usdc":0,"cycles":0,"wins":0,"losses":0}}' > .bot-state/state.json
          echo "timestamp,type,token,side,usd,token_qty,price_usd,txid_or_key,notes" > .bot-logs/placeholder.csv
          echo '{"status":"init"}' > .bot-logs/placeholder.json

      - name: Healthcheck (price / quote / swap payload)
        env:
          WALLET_ADDRESS: ${{ secrets.WALLET_ADDRESS }}
          PRIVATE_KEY:    ${{ secrets.PRIVATE_KEY }}
          DRY_RUN:        ${{ inputs.dry_run || 'true' }}
        run: |
          node - <<'NODE'
          // Minimal diagnostic: prints raw OK/ERR for price, quote, swap payload
          const API_BASE = process.env.API_BASE;
          const WALLET   = process.env.WALLET_ADDRESS;
          const PK       = process.env.PRIVATE_KEY;

          if (!WALLET?.startsWith("eth|")) console.log("WARN WALLET format should be eth|0x...");
          if (!PK?.startsWith("0x")) console.log("WARN PRIVATE_KEY should start with 0x...");

          async function get(path, params={}) {
            const u = new URL(path, API_BASE);
            Object.entries(params).forEach(([k,v])=>u.searchParams.set(k,String(v)));
            const r = await fetch(u);
            const txt = await r.text();
            return { ok: r.ok, status: r.status, body: txt };
          }
          async function post(path, body) {
            const r = await fetch(`${API_BASE}${path}`, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) });
            const txt = await r.text();
            return { ok: r.ok, status: r.status, body: txt };
          }
          function tok(key){ const [c,cat,t,ak]=key.split("$"); return { collection:c, category:cat, type:t, additionalKey:ak }; }

          (async ()=>{
            const T_GALA  = process.env.T_GALA;
            const T_GWETH = process.env.T_GWETH;
            const T_GUSDC = process.env.T_GUSDC;

            // PRICE
            console.log("== PRICE GALA ==");
            let res = await get("/v1/trade/price", { token: T_GALA });
            console.log(res.status, res.ok ? res.body : `ERR ${res.body}`);

            // QUOTE (GUSDC->GALA, $1)
            console.log("== QUOTE GUSDC->GALA $1 ==");
            res = await get("/v1/trade/quote", { tokenIn: T_GUSDC, tokenOut: T_GALA, amountIn: 1, fee: 3000 });
            console.log(res.status, res.ok ? res.body : `ERR ${res.body}`);

            // SWAP PAYLOAD (unsigned, minOut=0)
            console.log("== SWAP PAYLOAD (unsigned) GUSDC->GALA $1 ==");
            const body = {
              tokenIn: tok(T_GUSDC),
              tokenOut: tok(T_GALA),
              amountIn: "1",
              fee: 3000,
              sqrtPriceLimit: "0",
              amountInMaximum: "1",
              amountOutMinimum: "0"
            };
            res = await post("/v1/trade/swap", body);
            console.log(res.status, res.ok ? res.body : `ERR ${res.body}`);
          })().catch(e=>{ console.error("HC ERROR", e); process.exit(1); });
          NODE

      - name: Run bot (DRY mode recommended)
        env:
          WALLET_ADDRESS: ${{ secrets.WALLET_ADDRESS }}
          PRIVATE_KEY:    ${{ secrets.PRIVATE_KEY }}
          DRY_RUN:        ${{ inputs.dry_run || 'true' }}
        run: |
          node - <<'NODE'
          import fs from "node:fs";
          import path from "node:path";
          import crypto from "node:crypto";
          import { signatures } from "@gala-chain/api";

          // ========= Config =========
          const API_BASE = process.env.API_BASE;
          const DRY_RUN  = (process.env.DRY_RUN || "true").toLowerCase()==="true";
          const WALLET   = process.env.WALLET_ADDRESS;
          const PRIVKEY  = process.env.PRIVATE_KEY;

          const DCA_USD = +process.env.DCA_USD_PER_ASSET || 1;
          const BASE_TP = (+process.env.BASE_TP_PCT || 0.4)/100;
          const MIN_PROFIT = (+process.env.MIN_PROFIT_PCT || 0.8)/100;
          const STRONG_SIG = (+process.env.STRONG_SIGNAL_PCT || 1.6)/100;
          const ARB_MIN = +process.env.ARB_MIN_USD || 1;
          const ARB_MAX = +process.env.ARB_MAX_USD || 1;
          const FEE_TIER = +process.env.DEFAULT_FEE_TIER || 3000;
          const SLIP = (+process.env.SLIPPAGE_PCT || 0.6)/100;

          const MAX_EACH = +process.env.MAX_POSITION_USD_PER_TOKEN || 25;
          const MAX_NET  = +process.env.MAX_NET_EXPOSURE_USD || 50;

          const T = { GUSDC: process.env.T_GUSDC, GALA: process.env.T_GALA, GWETH: process.env.T_GWETH };

          const stateDir = ".bot-state";
          const statePath = path.join(stateDir,"state.json");
          const logDir = ".bot-logs";
          const runId = Date.now();
          const csvPath = path.join(logDir, `trades_${runId}.csv`);
          const jsonPath = path.join(logDir, `run_${runId}.json`);
          fs.writeFileSync(csvPath,"timestamp,type,token,side,usd,token_qty,price_usd,txid_or_key,notes\n",{flag:"a"});

          function loadState(){ try { return JSON.parse(fs.readFileSync(statePath,"utf8")); } catch { return { positions:{GALA:{qty:0,avg:0},GWETH:{qty:0,avg:0}}, pnl:{realized_usdc:0,cycles:0} }; } }
          function saveState(s){ fs.writeFileSync(statePath, JSON.stringify(s,null,2)); }
          function logCSV(...c){ fs.writeFileSync(csvPath, c.join(",")+"\n", {flag:"a"}); }

          async function get(path, params={}) {
            const u = new URL(path, API_BASE);
            Object.entries(params).forEach(([k,v])=>u.searchParams.set(k,String(v)));
            const r = await fetch(u);
            if (!r.ok) throw new Error(`${path} ${r.status} ${await r.text()}`);
            return r.json();
          }
          async function post(path, body) {
            const r = await fetch(`${API_BASE}${path}`, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) });
            if (!r.ok) throw new Error(`${path} ${r.status} ${await r.text()}`);
            return r.json();
          }
          function tokObj(k){ const [c,cat,t,ak]=k.split("$"); return {collection:c, category:cat, type:t, additionalKey:ak}; }
          async function price(tk){ const j = await get("/v1/trade/price",{token: tk}); return +(j?.data?.price ?? j?.price); }
          async function quote(tin,tout,ain){ const j = await get("/v1/trade/quote",{tokenIn:tin, tokenOut:tout, amountIn:ain, fee:FEE_TIER}); return +(j.data?.amountOut ?? j.amountOut ?? 0); }
          async function swapPayload(tin,tout,ain,minOut){
            // IMPORTANT: use amountOutMinimum: "0" for compatibility while debugging
            const body = { tokenIn:tokObj(tin), tokenOut:tokObj(tout), amountIn:String(ain), fee:FEE_TIER, sqrtPriceLimit:"0", amountInMaximum:String(ain), amountOutMinimum:String(Math.max(0,minOut||0)) };
            const j = await post("/v1/trade/swap", body);
            return j.data;
          }
          async function bundle(payload, type="swap"){
            const key = signatures.normalizePrivateKey(PRIVKEY);
            const withKey = { ...payload, uniqueKey: payload.uniqueKey || `galaswap-operation-${crypto.randomUUID()}` };
            const signature = signatures.getSignature(withKey, key);
            const j = await post("/v1/trade/bundle", { payload: withKey, type, signature, user: WALLET });
            return j.data?.data || j.data;
          }
          async function execSwap(tin,tout,ain,eout){
            const minOut = eout * (1 - SLIP);
            const payload = await swapPayload(tin,tout,ain,minOut);
            if (DRY_RUN) return {dry:true, id: payload.uniqueKey};
            const id = await bundle(payload,"swap");
            return {dry:false, id};
          }

          // In DRY_RUN, pretend we have funds so we don’t fail on balance calls
          async function getBalance(){ return DRY_RUN ? Number.MAX_SAFE_INTEGER : 0; }

          async function run(){
            if (!WALLET?.startsWith("eth|")) throw new Error("WALLET_ADDRESS must be eth|0x...");
            if (!PRIVKEY?.startsWith("0x")) throw new Error("PRIVATE_KEY must start with 0x...");

            const state = loadState();
            const [galaPx, gwethPx] = await Promise.all([ price(T.GALA), price(T.GWETH) ]);
            let gusdcBal = await getBalance();

            // DCA buys (only log in DRY by default)
            if (gusdcBal >= DCA_USD) {
              const outGala = await quote(T.GUSDC, T.GALA, DCA_USD);
              const rG = await execSwap(T.GUSDC, T.GALA, DCA_USD, outGala);
              const pG = state.positions.GALA; const newQtyG = pG.qty + outGala; const newAvgG = (pG.qty*pG.avg + DCA_USD)/newQtyG;
              state.positions.GALA = { qty:newQtyG, avg:newAvgG }; gusdcBal -= DCA_USD;
              logCSV(Date.now(),"dca","GALA","BUY",DCA_USD.toFixed(2),outGala.toFixed(8),(DCA_USD/outGala).toFixed(8),rG.id,"dca");
            }

            if (gusdcBal >= DCA_USD) {
              const outW = await quote(T.GUSDC, T.GWETH, DCA_USD);
              const rW = await execSwap(T.GUSDC, T.GWETH, DCA_USD, outW);
              const pW = state.positions.GWETH; const newQtyW = pW.qty + outW; const newAvgW = (pW.qty*pW.avg + DCA_USD)/newQtyW;
              state.positions.GWETH = { qty:newQtyW, avg:newAvgW }; gusdcBal -= DCA_USD;
              logCSV(Date.now(),"dca","GWETH","BUY",DCA_USD.toFixed(2),outW.toFixed(8),(DCA_USD/outW).toFixed(8),rW.id,"dca");
            }

            // Simple arb probe with $1
            const seqs = [["GUSDC","GALA","GWETH","GUSDC"],["GUSDC","GWETH","GALA","GUSDC"]];
            for (const seq of seqs){
              let amt = 1; const legs = [];
              for (let i=0;i<seq.length-1;i++){
                const out = await quote(T[seq[i]], T[seq[i+1]], amt);
                legs.push({in:seq[i], out:seq[i+1], ain:amt, aout:out});
                amt = out;
              }
              const pct = (amt-1)/1;
              console.log("ARB PROBE", seq.join("→"), "expProfit=", (pct*100).toFixed(3), "%");
            }

            state.pnl.cycles += 1;
            fs.writeFileSync(jsonPath, JSON.stringify({ time:new Date().toISOString(), prices:{GALA:galaPx,GWETH:gwethPx}, dryRun:DRY_RUN }, null, 2));
            fs.writeFileSync(statePath, JSON.stringify(state,null,2));
          }

          run().catch(err=>{
            const errPath = path.join(".bot-logs", `run_error_${Date.now()}.json`);
            fs.writeFileSync(errPath, JSON.stringify({ error: String(err?.message||err), stack: err?.stack||null }, null, 2));
            console.error("❌ bot error:", err);
            process.exit(1);
          });
          NODE

      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gala-bot-logs
          path: |
            .bot-logs/*.csv
            .bot-logs/*.json
          if-no-files-found: warn
